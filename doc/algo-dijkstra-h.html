<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- dijkstra.cpp -->
  <title>&lt;algo/dijkstra.h&gt; - dijkstra | Algo </title>
<link rel="stylesheet" type="text/css" href="style/offline.css" />
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li>&lt;algo/dijkstra.h&gt; - dijkstra</li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar"><div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">&lt;algo/dijkstra.h&gt; - dijkstra</h1>
<span class="subtitle"></span>
<!-- $$$<algo/dijkstra.h>-brief -->
<p>Dijkstra's shortest path algorithm <a href="#details">More...</a></p>
<!-- @@@<algo/dijkstra.h> -->
<ul>
</ul>
<a name="Functions"></a>
<h2 id="Functions">Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="algo-dijkstra-h.html#dijkstra">dijkstra</a></b>(const std::vector&lt;std::vector&lt;dijkstra_neighbor&lt;WeightType&gt; &gt; &gt; &amp;<i> adjacency_list</i>, int<i> source</i>, std::vector&lt;WeightType&gt; &amp;<i> min_distance</i>, std::vector&lt;int&gt; &amp;<i> previous</i>, WeightType<i> infinite_weight</i>, int<i> hashtable_init_capacity</i> = 256)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> std::vector&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="algo-dijkstra-h.html#dijkstra_path">dijkstra_path</a></b>(const std::vector&lt;int&gt; &amp;<i> previous</i>, int<i> source</i>, int<i> destination</i>)</td></tr>
</table></div>
<!-- $$$<algo/dijkstra.h>-description -->
<div class="descr"> <a name="details"></a>
<p>This file provides a modular way to use Dijkstra's shortest path algorithm.</p>
</div>
<!-- @@@<algo/dijkstra.h> -->
<h2>Function Documentation</h2>
<!-- $$$dijkstra[overload1]$$$dijkstraconststd::vector<std::vector<dijkstra_neighbor<WeightType>>>&intstd::vector<WeightType>&std::vector<int>&WeightTypeint -->
<h3 class="fn" id="dijkstra"><a name="dijkstra"></a><span class="type">void</span> <span class="name">dijkstra</span>(const <span class="type">std::vector</span>&lt;<span class="type">std::vector</span>&lt;<span class="type"><a href="dijkstra-neighbor.html">dijkstra_neighbor</a></span>&lt;<span class="type">WeightType</span>&gt; &gt; &gt; &amp;<i> adjacency_list</i>, <span class="type">int</span><i> source</i>, <span class="type">std::vector</span>&lt;<span class="type">WeightType</span>&gt; &amp;<i> min_distance</i>, <span class="type">std::vector</span>&lt;<span class="type">int</span>&gt; &amp;<i> previous</i>, <span class="type">WeightType</span><i> infinite_weight</i>, <span class="type">int</span><i> hashtable_init_capacity</i> = 256)</h3>
<p>Computes the Dijkstra's algorithm in order to retrieve the minimum distances <i>min_distance</i> and the predecessors <i>previous</i> corresponding to the shortest paths starting at the vertex <i>source</i>.</p>
<p>Vertices are labelled with integers whereas weights can have any type, as long as they implement the &lt; operator, and conversion from int (0).</p>
<p><i>adjacency_list</i> defines the structure of the graph.</p>
<p><i>infinite_weight</i> shall be set to the maximum value reachable with the type <code>WeightType</code>. In case <code>WeightType</code> is a basic type, std::numeric_limits&lt;WeightType&gt;::infinity() or std::numeric_limits&lt;WeightType&gt;::max() should be used, when available.</p>
<p>Finally, <i>hashtable_init_capacity</i> may be specified as a optimizing factor when the size of the problem is known: it is the size given to the vertex hashmap during the initialization.</p>
<p><b>See also </b><a href="dijkstra-neighbor.html#dijkstra_neighbor">dijkstra_neighbor::dijkstra_neighbor</a>() and <a href="algo-dijkstra-h.html#dijkstra_path">dijkstra_path</a>().</p>
<!-- @@@dijkstra -->
<!-- $$$dijkstra_path[overload1]$$$dijkstra_pathconststd::vector<int>&intint -->
<h3 class="fn" id="dijkstra_path"><a name="dijkstra_path"></a><span class="type">std::vector</span>&lt;<span class="type">int</span>&gt; <span class="name">dijkstra_path</span>(const <span class="type">std::vector</span>&lt;<span class="type">int</span>&gt; &amp;<i> previous</i>, <span class="type">int</span><i> source</i>, <span class="type">int</span><i> destination</i>)</h3>
<p>Extracts a specific shortest path in the graph.</p>
<p>Extracts a path from the <i>source</i> vertex to some <i>destination</i> vertex, using the previously-computed vector value <i>previous</i>. Returns a vector of vertex identifiers, starting with <i>source</i> and ending with <i>destination</i> and corresponding to the shortest path according to <i>previous</i>.</p>
<p><b>Warning:</b> For efficiency reasons, there is no check whether or not destination is reachable. to avoid any infinite loop behavior, please check beforehand that the <code>min_distance</code> value corresponding to <i>destination</i> is not infinite.</p>
<p><b>See also </b><a href="algo-dijkstra-h.html#dijkstra">dijkstra</a>().</p>
<!-- @@@dijkstra_path -->
        </div>
       </div>
   </div>
   </div>
</div>
</body>
</html>
